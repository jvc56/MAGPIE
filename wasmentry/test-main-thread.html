<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>MAGPIE WASM - Main Thread with PROXY_TO_PTHREAD</title>
    <style>
      body {
        font-family: monospace;
        max-width: 1200px;
        margin: 20px auto;
        padding: 0 20px;
      }
      .status {
        padding: 10px;
        margin: 10px 0;
        background: #f0f0f0;
        border-radius: 4px;
        font-weight: bold;
      }
      .status.error { background: #ffebee; color: #c62828; }
      .status.success { background: #e8f5e9; color: #2e7d32; }
      textarea {
        width: 100%;
        font-family: monospace;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 10px;
        box-sizing: border-box;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        background: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 10px 5px 10px 0;
      }
      button:hover:not(:disabled) { background: #1976d2; }
      button:disabled { background: #ccc; cursor: not-allowed; }
      .info {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 4px;
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <h1>MAGPIE WASM - Main Thread Test</h1>

    <div class="info">
      <strong>Using PROXY_TO_PTHREAD</strong> - WASM loads on main thread but work runs in pthreads.
      UI stays responsive!
    </div>

    <div class="status" id="status">Loading WASM...</div>

    <h3>CGP Input:</h3>
    <textarea id="inputParams" rows="4" placeholder="Enter CGP string"></textarea>

    <button type="button" id="submitButton" disabled>Run Simulation</button>

    <h3>Output:</h3>
    <textarea id="output" rows="20" readonly></textarea>

    <script type="module">
      const statusElement = document.getElementById("status");
      const submitButton = document.getElementById("submitButton");
      const inputElement = document.getElementById("inputParams");
      const outputElement = document.getElementById("output");

      let Module = null;
      let magpieReady = false;
      let precacheFileData, wasmMagpieInit, wasmRunCommand, wasmGetOutput, wasmGetError;

      function setStatus(text, type = "") {
        statusElement.textContent = text;
        statusElement.className = "status " + type;
        console.log("[Status]", text);
      }

      function appendOutput(text) {
        outputElement.value += text + "\n";
        outputElement.scrollTop = outputElement.scrollHeight;
      }

      // Import and initialize WASM
      import('./magpie_wasm.mjs').then(async module => {
        console.log('WASM module imported', module);
        console.log('Module keys:', Object.keys(module));

        const MAGPIE = module.default || module.MAGPIE || module;
        console.log('MAGPIE factory:', typeof MAGPIE);

        if (typeof MAGPIE !== 'function') {
          throw new Error('MAGPIE is not a function. Available exports: ' + Object.keys(module).join(', '));
        }

        const mod = await MAGPIE({
          print: (text) => console.log('[WASM]', text),
          printErr: (text) => {
            if (text.includes('program exited') && text.includes('keepRuntimeAlive')) {
              console.log('[WASM] Runtime initialized');
              return;
            }
            console.error('[WASM]', text);
          },
          onRuntimeInitialized: () => {
            console.log('[WASM] Runtime fully initialized');
          }
        });

        Module = mod;
        console.log('WASM initialized');

        // Wrap functions - synchronous calls like old implementation
        precacheFileData = Module.cwrap('precache_file_data', null, ['number', 'number', 'number']);
        wasmMagpieInit = Module.cwrap('wasm_magpie_init', 'number', ['number']);
        wasmRunCommand = Module.cwrap('wasm_run_command', 'number', ['number']);
        wasmGetOutput = Module.cwrap('wasm_get_output', 'number', []);
        wasmGetError = Module.cwrap('wasm_get_error', 'number', []);

        magpieReady = true;
        setStatus("✓ WASM ready", "success");
        submitButton.disabled = false;
      }).catch(error => {
        console.error('Failed to load WASM:', error);
        setStatus("Failed to load WASM: " + error.message, "error");
      });

      // Button handler
      submitButton.addEventListener("click", async () => {
        if (!magpieReady) return;

        submitButton.disabled = true;
        const cgpstring = inputElement.value.trim();

        // Parse lexicon from CGP
        const vals = cgpstring.split(" ");
        if (vals.length < 6) {
          setStatus("Error: need valid CGP string", "error");
          submitButton.disabled = false;
          return;
        }

        let lexicon = "";
        for (let i = 4; i < vals.length; i += 2) {
          if (vals[i] === "lex") {
            lexicon = vals[i + 1].replace(';', '');
            break;
          }
        }

        if (!lexicon) {
          setStatus("Error: need lexicon in CGP", "error");
          submitButton.disabled = false;
          return;
        }

        outputElement.value = "";
        setStatus("Precaching files...");

        // Precache files
        const files = [
          `data/lexica/${lexicon}.kwg`,
          "data/letterdistributions/english.csv",
          `data/lexica/${lexicon}.klv2`,
          "data/strategy/winpct.csv",
          "data/layouts/standard15.txt",
        ];

        for (const filename of files) {
          try {
            const url = '/' + filename;
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('Not found');

            const arrBuffer = new Uint8Array(await resp.arrayBuffer());
            const filenamePtr = Module.stringToNewUTF8(filename);
            const buf = Module._malloc(arrBuffer.length);
            Module.HEAPU8.set(arrBuffer, buf);

            precacheFileData(filenamePtr, buf, arrBuffer.length);

            Module._free(buf);
            Module._free(filenamePtr);
            console.log('✓ Precached:', filename);
          } catch (error) {
            appendOutput(`❌ Failed to load ${filename}`);
          }
        }

        // Initialize MAGPIE
        setStatus("Initializing MAGPIE...");
        const dataPathPtr = Module.stringToNewUTF8("data");
        const initResult = wasmMagpieInit(dataPathPtr);
        Module._free(dataPathPtr);

        if (initResult !== 0) {
          setStatus("Failed to initialize MAGPIE", "error");
          submitButton.disabled = false;
          return;
        }

        // Run commands
        const nthreads = Math.min(Math.max(navigator.hardwareConcurrency || 4, 1), 20);
        // Strip lex from CGP string - it's set separately
        let cleanCgp = cgpstring;
        const lexIndex = cleanCgp.indexOf(' lex ');
        if (lexIndex !== -1) {
          cleanCgp = cleanCgp.substring(0, lexIndex);
        }
        // Also handle -lex format
        const dashLexIndex = cleanCgp.indexOf(' -lex ');
        if (dashLexIndex !== -1) {
          cleanCgp = cleanCgp.substring(0, dashLexIndex);
        }
        const commands = [
          `set -lex ${lexicon}`,
          `cgp ${cleanCgp}`,
          `generate`,
          `sim -numplays 15 -threads ${nthreads}`,
        ];

        setStatus("Running simulation...");
        appendOutput(`▶ Starting with ${nthreads} threads...\n`);

        for (const cmd of commands) {
          console.log('Running:', cmd);
          const cmdPtr = Module.stringToNewUTF8(cmd);
          const exitCode = wasmRunCommand(cmdPtr);  // Blocks during execution
          Module._free(cmdPtr);

          console.log('Exit code:', exitCode);

          if (exitCode !== 0) {
            const errorPtr = wasmGetError();
            if (errorPtr) {
              const error = Module.UTF8ToString(errorPtr);
              Module._free(errorPtr);
              appendOutput(`❌ Error: ${error}`);
            }
            setStatus("Command failed", "error");
            submitButton.disabled = false;
            return;
          }
        }

        // Get output
        const outputPtr = wasmGetOutput();
        if (outputPtr) {
          const output = Module.UTF8ToString(outputPtr);
          Module._free(outputPtr);
          appendOutput(output);
        }

        setStatus("✓ Complete", "success");
        submitButton.disabled = false;
      });
    </script>
  </body>
</html>
